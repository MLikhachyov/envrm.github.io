<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="ru-RU">
  <head>
    <meta charset="utf-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Personal page">
    <meta name="author" content="Likhachev Maxim">

    <link rel="shortcut icon" href="../../../../../../ico/favicon.ico">

    <title>#!/usr/bin/env rm -- Заметки и переводы :: Основы Slackware Linux -- 8. Файлы и директории</title>

    <link rel="stylesheet" href="../../../../../../css/bootstrap.min.css">
    <link rel="stylesheet" href="../../../../../../css/custom.css">
    <link rel="stylesheet" href="../../../../../../css/fontello.css">
    <link rel="stylesheet" href="../../../../../../css/animation.css">

    <link rel="stylesheet" href="../../../../../../css/shell-wrap.css">

    <script type="text/javascript" src="../../../../../../js/SyntaxHighlighter/shCore.js"></script>

		<link href="../../../../../../css/SyntaxHighlighter/shCore.css" rel="stylesheet" type="text/css" />

		<link href="../../../../../../css/SyntaxHighlighter/shThemeEclipse.css" rel="stylesheet" type="text/css" />
		<!-- <link href="../../../../../../css/SyntaxHighlighter/shThemeDjango.css" rel="stylesheet" type="text/css" /> -->
		<!-- <link href="../../../../../../css/SyntaxHighlighter/shThemeEmacs.css" rel="stylesheet" type="text/css" /> -->
		<!-- <link href="../../../../../../css/SyntaxHighlighter/shThemeFadeToGrey.css" rel="stylesheet" type="text/css" /> -->
		<!-- <link href="../../../../../../css/SyntaxHighlighter/shThemeMDUltra.css" rel="stylesheet" type="text/css" /> -->
		<!-- <link href="../../../../../../css/SyntaxHighlighter/shThemeMidnight.css" rel="stylesheet" type="text/css" /> -->
		<!-- <link href="../../../../../../css/SyntaxHighlighter/shThemeRDark.css" rel="stylesheet" type="text/css" /> -->

		<script type="text/javascript" src="../../../../../../js/SyntaxHighlighter/shBrushScheme.js"></script>
		<script type="text/javascript" src="../../../../../../js/SyntaxHighlighter/shBrushTcl_simple.js"></script>
		<script type="text/javascript" src="../../../../../../js/SyntaxHighlighter/shBrushBash.js"></script>
		<script type="text/javascript" src="../../../../../../js/SyntaxHighlighter/shBrushErlang.js"></script>
		<script type="text/javascript" src="../../../../../../js/SyntaxHighlighter/shBrushPlain.js"></script>
		<script type="text/javascript" src="../../../../../../js/SyntaxHighlighter/shBrushBash.js"></script>
		<script type="text/javascript" src="../../../../../../js/SyntaxHighlighter/shBrushLatex.js"></script>
		<script type="text/javascript" src="../../../../../../js/SyntaxHighlighter/shBrushHaskell.js"></script>
		<script type="text/javascript" src="../../../../../../js/SyntaxHighlighter/shBrushProlog.js"></script>
		<script type="text/javascript" src="../../../../../../js/SyntaxHighlighter/shBrushDiff.js"></script>
		<script type="text/javascript" src="../../../../../../js/SyntaxHighlighter/shBrushVim.js"></script>
		<script type="text/javascript" src="../../../../../../js/SyntaxHighlighter/shBrushJScript.js"></script>
		<script type="text/javascript" src="../../../../../../js/SyntaxHighlighter/shBrushBat.js"></script>
		<script type="text/javascript" src="../../../../../../js/SyntaxHighlighter/shBrushXml.js"></script>
		<script type="text/javascript" src="../../../../../../js/SyntaxHighlighter/shBrushCss.js"></script>

<script type="text/javascript">
			SyntaxHighlighter.defaults['toolbar'] = false;
			SyntaxHighlighter.all()
		</script>

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="container">
      <div class="header">
        <ul class="nav navbar-nav pull-right">
          <li class="menu-icon"><a href="../../../../../../index.html"><span class="icon-home"></span></a></li>
          <li class="menu-icon"><a href="../../../../programming.html"><span class="icon-tools"></span></a></li>
          <li class="menu-icon"><a href="../../../../poetry.html"><span class="icon-feather"></span></a></li>
          <li class="menu-icon"><a href="../../../../music.html"><span class="icon-note-beamed"></span></a></li>
          <li class="menu-icon active"><a href="../../../../articles.html"><span class="icon-book"></span></a></li>
          <li class="menu-icon"><a href="../../../../about.html"><span class="icon-user"></span></a></li>
        </ul>
        <h3 class="text-muted">#!/usr/bin/env rm</h3>
      </div>

      <ol class="plain breadcrumb">
        <li><a href="../../../../articles.html"><span class="icon-book"></span></a></li>
        <li><a href="index.html">Основы Slackware Linux</a></li>
        <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                II. Основы Slackware Linux <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
              <li><a href="00. Предисловие.html">Предисловие</a></li>
              <li><a href="01. Об этой книге.html"><span>I.</span> Начало</a>
              <li style="text-decoration: underline;"><a href="08. Файлы и директории.html"><span>II.</span> Основы Slackware Linux</a>
              <li><a href="11. LaTeX.html"><span>III.</span> Набор и редактирование текста</a>
              <li><a href="12. Чтение и отправка электронной почты с mutt.html"><span>IV.</span> Электронная почта</a>
              <li><a href="14. Управление пользователями.html"><span>V.</span> Системное администрирование</a>
              <li><a href="22. Настройка сети.html"><span>VI.</span> Сетевое администрирование</a>
            </ul>
        </li>
        <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                8. Файлы и директории <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
              <li><a href="07. Оболочка командной строки.html">7. Оболочка командной строки</a></li>
              <li style="text-decoration: underline;"><a href="08. Файлы и директории.html">8. Файлы и директории</a></li>
              <li><a href="09. Работа с текстом.html">9. Работа с текстом</a></li>
              <li><a href="10. Управление процессами.html">10. Управление процессами</a></li>
            </ul>
        </li>
      </ol>

      <div class="row columns">

        <h3 class="text-center">8. Файлы и директории</h3>

<br />

        <div class="col-lg-1">
        </div>

<div class="article col-lg-10 text-justify">

<h4 id="1">8.1. Немного теории</h4>

<p>Прежде чем мы перейдём к рассмотрению конкретных операций на файловых системах,
мы совершим более теоретический обзор принципов работы ФС в
UNIX-подобных системах. Slackware Linux поддерживает множество
различных файловых систем, но виртуально все эти ФС используют схожую
семантику. Эта семантика обеспечивается слоем VFS (Virtual File System,
Виртуальная файловая система), базовым уровнем для работы дисковых устройств и
сетевых файловых систем.</p>

<h5>8.1.1. Индексные дескрипторы, директории и данные</h5>

<p>Файловые системы состоят из элементов двух типов: данных и метаданных.
Метаданные описывают актуальные блоки данных, находящихся на диске. Большинство
файловых систем использует информационные (индексные) дескрипторы (inode) для
сохранения метаданных. Общие дескрипторы таковы:</p>

<p class="text-right"><strong>Таблица 8.1. Общие поля inode</strong></p>

    <table class="table table-striped">
      <thead>
        <tr>
          <th>Поле</th>
          <th>Описание</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>mode</th>
	  <td>права доступа.</td>
        </tr>
        <tr>
          <th>uid</th>
	  <td>идентификатор пользователя-владельца файла.</td>
        </tr>
        <tr>
          <th>gid</th>
	  <td>идентификатор группы-владельца файла.</td>
        </tr>
        <tr>
          <th>size</th>
	  <td>размер файла в байтах.</td>
        </tr>
        <tr>
          <th>ctime</th>
	  <td>время создания файла.</td>
        </tr>
        <tr>
          <th>mtime</th>
	  <td>время последней модификации файла.</td>
        </tr>
        <tr>
          <th>links_count</th>
	  <td>количество ссылок, указывающих на этот файл.</td>
        </tr>
        <tr>
          <th>i_block</th>
	  <td>указатели на блок данных.</td>
        </tr>
      </tbody>
    </table>

<p>Если вы с UNIX или Linux не на «ты», то эти имена могут показаться нелепыми, но
мы разъясним каждое из них в соответствующих параграфах. В любом случае, в этой
таблице вы можете увидеть связь между индексными дескрипторами и данными,
особенно это касается поля <var>i_block</var>: каждый inode содержит указатели на
представляемые ими блоки данных. Дескрипторы и блоки данных и представляют
собой файлы в действительности.</p>

<p>Вы можете поинтересоваться тем, где содержатся имена файлов (и директорий),
ведь в списке индексных дескрипторов нет такого поля. На самом деле,
имена файлов разделены между дескрипторами и блоками данных, что
позволяет вам делать примечательные вещи, такие как назначить
единственному файлу несколько имён. Названия файлов хранятся в так
называемых записях директорий. Эти записи определяют имена файлов и
соответствующие им индексные дескрипторы. Так как директории тоже
представлены с помощью <var>inode</var>, структура директорий создаётся по такому
же принципу.</p>

<p>Мы можем привести простой пример, как это всё работает, продемонстрировав,
какие действия совершает ядро при выполнении команды <strong>cat
/home/daniel/note.txt</strong>.</p>

<p>Система прочитывает дескриптор корневой директории <code>/</code>,
проверяет, доступен ли он на чтение данному пользователю, и читает блоки
данных, чтобы найти номер <var>inode</var> домашней директории.</p>

<p>Система прочитывает дескриптор домашней директории <code>/home/</code>,
проверяет, доступен ли он на чтение данному пользователю, и читает блоки
данных, чтобы найти номер <var>inode</var> домашней директории.</p>

<p>Система прочитывает дескриптор директории <code>/home/daniel/</code>,
проверяет, доступен ли он на чтение данному пользователю, и читает блоки
данных, чтобы найти номер <var>inode</var> файла <code>note.txt</code>.</p>

<p>Система прочитывает дескриптор файла <code>/home/daniel/note.txt</code>,
проверяет, доступен ли он на чтение данному пользователю, и возвращает блоки
данных программе <strong>cat</strong> при помощи системного вызова
<var>read()</var>.</p>

<h5>8.1.2. Права на файлы</h5>

<p>Ранее мы говорили, что Linux является многопользовательской системой. Это
означает, что каждый пользователь имеет собственные файлы (которые обычно
располагаются в домашней директории). Вместе с тем пользователи могут быть
членами групп, которые добавляют дополнительные привилегии.</p>

<p>Как вы видели выше в таблице индексных дескрипторов, каждый файл имеет
владельца и соотнесён с группой. Традиционная система контроля доступа UNIX
различает права на чтение, запись или выполнение файла. Эти права хранятся в
поле индексного дескриптора mode. Это поле представляет права в форме четырёх
восьмеричных чисел. Первое число означает специальные опции, второе хранит
права владельца, третье &#8211; группы, а четвёртое &#8211; права остальных
пользователей. Права назначаются добавлением или удалением одного из следующих
чисел:</p>

<p class="text-right"><strong>Таблица 8.2. Значение чисел октета</strong></p>

    <table class="table table-striped">
      <thead>
        <tr>
          <th>Число</th>
          <th>Значение</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>1</th>
	  <td>Выполнение (x, eXecute)</td>
        </tr>
        <tr>
          <th>2</th>
	  <td>Запись (w, Write)</td>
        </tr>
        <tr>
          <th>4</th>
	  <td>Чтение (r, Read)</td>
        </tr>
      </tbody>
    </table>

<p>Так, допустим, что файлу назначены права 0644. Это означает, что файл доступен
на чтение и запись владельцу (6), а группе и остальным пользователям на чтение
(4).</p>

<p>Большинство пользователей не желают иметь дела с восьмеричными числами, поэтому
существует множество утилит, которые работают в том числе и с алфавитным
представлением прав доступа. В этой нотации используются символы, перечисленые
в Таблице 8.2. «Значение чисел октета», указанные в скобках. В следующем
примере приведена информация о файле в режиме 0644. Номера заменены тремя
rwx-триплетами (первый символ указывает на наличие специальных опций).</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ ls -l note.txt</li>
    <li>-rw-r--r--  1 daniel daniel 5 Aug 28 19:39 note.txt</li>
  </ul>
</div>

<p>Спустя годы традиционной для UNIX системы разграничения прав в некоторых
случаях стало недостаточно. Спецификация POSIX 1003.1e призвана расширить
модель управления доступом при помощи ACL (Access Control Lists, список
контроля доступа). К сожалению, эта попытка не доведена до конца, хотя
некоторые системы (например, GNU/Linux) реализовали ACL. Список контроля
доступа следует той же семантике, как и обычные файловые права, но но
предоставляет возможность указать rwx-значения для дополнительных пользователей
и групп.</p>

<p>Следующий пример содержит список контроля доступа для файла. Как вы можете
видеть, права выглядят обычно для UNIX (присутствуют режим доступа
пользователя, группы и всех остальных), но здесь имеется дополнительная запись
для пользователя <var>joe</var>.</p>

<pre class="brush: plain">
user::rwx
user:joe:r--
group::---
mask::r--
other::---
</pre>

<p>Для более комплексного (и совершенного) решения некоторые системы GNU/Linux
добавляют более мелкоструктурный контроль доступа при помощи MAC (Mandatory
Access Control, мандатное управление доступом), например, SELinux и AppArmor.
Но эти системы находятся за пределами данной книги.</p>

<h5>8.1.3. Ссылки</h5>

<p>Указатель, ссылающийся на inode, называется жёсткой ссылкой (hard link).
Большая часть файлов прилинкованы только единожды, но ничто не препятствует
созданию дополнительнных ссылок. Это действие увеличит значение поля
<var>links_count</var> в индексном дескрипторе. Это позволяет системе
определить незанятые файлами дескрипторы и блоки данных. Если значение
<var>links_count</var> равно нулю, то данный дескриптор ни на что не ссылается,
и может быть переопределён.</p>

<p><strong>Изображение 8.1. Структура жёсткой ссылки</strong></p>

<p align="center">
  <img class="shadow img-responsive" src="img/08.1-1.png" alt="hardlink">
</p>

<p>У жёстких ссылок есть два ограничения. Прежде всего, жёсткая ссылка не может
быть установлена между разными файловыми системами, т.к. она связывает
индексные дескрипторы. Это связано с тем, каждая файловая система имеет
собственные дескрипторы и, следовательно, их номера. Также большая часть ФС не
позволяет создавать жёсткие ссылки на директории, так как это может вызвать
зацикливание иерархии директорий, что может привести к различного рода
блокировкам и нарушает целостность файловой системы. В добавлении к этому,
большинство реализаций команд rm и rmdir не умеют работать с жёсткими ссылками.</p>

<p>Этих ограничений нет у символических ссылок, потому что они указывают не на
inode, а на имена файлов. Когда операционная система сталкивается с
символической ссылкой, она следует по представляемому ею пути. Символическая
ссылка также может ссылаться на несуществующий файл, т.к. она лишь содержит
имя. Такие ссылки называются висящими.</p>

<p><strong>Изображение 8.2. Структура символической ссылки</strong></p>

<p align="center">
  <img class="shadow img-responsive" src="img/08.1-2.png" alt="symlink">
</p>

<div class="bq-note">
    <h4 class="text-success">Примечание</h4>
    <p>Если вы причастны к системному администрированию, будет хорошо знать о
    безопасности жёстких ссылок. Если директория <code>/home</code> расположена
    в файловой системе, содержащей каки-либо системные программы, тогда
    пользователь будет способен создать жёсткие ссылки, ссылающиеся на них.
    Даже если уязвимая программа будет обновлена, ссылка в домашней директории
    пользователя всё равно будет указывать на старый исполнимый файл, позволяя
    пользователю выполнять уязвимую программу.</p>
</div>

<p>В такой ситуации хорошей идеей будет помещать директории, доступные для записи
пользователям на отдельных файловых системах. На практике это означает, что
нужно отделить как минимум директории <code>/home</code> и
<code>/tmp</code>.</p>

<h4 id="3">8.3. Работа с директориями</h4>

<p>Мы кратко рассмотрели вопрос функционирования системы директорий в
<a href="#1">секции 8.1.1</a>, сейчас же мы обратимся к некоторым командам для
манипуляции с директориями.</p>

<h5>8.3.1. Просмотр директорий</h5>

<p>Команда <strong>ls</strong>, с которой мы уже знакомы по разделу 8.2.1, так
же может быть использована для просмотра директорий. Как мы знаем, по умолчанию
<strong>ls</strong> выводит файлы и директории, которые можно идетифицировать в расширенном
("long") режиме
вывода <strong>ls</strong>:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ ls -l</li>
    <li>total 36</li>
    <li>-rw-rw-r--  1 daniel daniel 12235 Sep  4 15:56 dns.txt</li>
    <li>-rw-rw-r--  1 daniel daniel  7295 Sep  4 15:56 network-hosts.txt</li>
    <li>drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers</li>
  </ul>
</div>

<p>Если указано имя директории или же шаблон подстановки, <strong>ls</strong> выведет содержимое
этой директории или всех директорий, имена которых совпадают с шаблоном.
Например, если существует директория papers, команда <strong>ls paper*</strong> выведет
содержимое этой директории. Это может обескуражить, если вам требуется всего
лишь вывести список директорий, а не их содержимое. Флаг <var>-d</var> позволит вам это
сделать:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ ls -ld paper*</li>
    <li>drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers</li>
  </ul>
</div>

<p>Вы так же можете вывести содержимое всех директорий и поддиректорий рекурсивно,
указав параметр <var>-R</var>:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ ls -R</li>
    <li>.:</li>
    <li>dns.txt  network-hosts.txt  papers</li>
    <br />
    <li>./papers:</li>
    <li>cs  phil</li>
    <br />
    <li>./papers/cs:</li>
    <li>entr.pdf</li>
    <br />
    <li>./papers/phil:</li>
    <li>logics.pdf</li>
  </ul>
</div>

<h5>8.3.2. Создание и удаление директорий</h5>

<p>В UNIX есть команда <strong>mkdir</strong>, используемая для создания директорий. Если указан
относительный путь, то директория будет создана в текущей директории. Базовый
синтаксис команды очень прост: <var>mkdir &lt;name&gt;</var>. Например:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
<li>$ mkdir mydir</li>
  </ul>
</div>

<p>По умолчанию, <strong>mkdir</strong> создаёт одну директорию. Так, если вы
решите создать директории <code>mydir/mysubdir</code>, <strong>mkdir</strong>
выдаст ошибку, если директория <code>mydir</code> ещё не существует. Но если вы
всё же хотите создать обе директории одной командой, то вам нужно указать
параметр <var>-p</var>:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
<li>$ mkdir -p mydir/mysubdir</li>
  </ul>
</div>

<p>Команда <strong>rmdir</strong> удаляет директории. Её поведение сходно с
поведением команды <strong>mkdir</strong>. Команда <strong>rmdir
mydir/mysubdir</strong> удалит только директорию <code>mysubdir</code>, тогда
как команда <strong>rmdir -p mydir/mysubdir</strong> удалит сначала
<code>mydir/mysubdir</code>, а затем и <code>mydir</code>.</p>

<p>Если в директории, которую вы удаляете, есть записи, то выполнение
<strong>rmdir</strong> остановится. В случае, если вам нужно удалить директорию
со всем содержимым, то используйте команду <strong>rm</strong>.</p>

<h4 id="4">8.4. Управление файлами и директориями</h4>

<h5>8.4.1. Копирование</h5>

<p>Файлы и директории могут быть скопированы командой <strong>cp</strong>. В самом
простом случае команде нужно передать имена файла-источника и результирующего
файла. Следующий пример сделает копию файла <code>file1</code> с именем
<code>file2</code>:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ cp file1 file2</li>
  </ul>
</div>
      
<p>Не будет сюрпризом, что относительные и абсолютные пути так же работают:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ cp file1 somedir/file2</li>
    <li>$ cp file1 /home/joe/design_documents/file2</li>
  </ul>
</div>
      
<p>Вторым параметром вы также можете указать директорию. В таком случае,
<code>cp</code> скопирует файлы в указанную директорию, сохранив оригинальные
имена. Если указано более двух параметров, то последний параметр будет
использован в качестве имени директории. Например:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ cp file1 file2 somedir</li>
  </ul>
</div>
      
<p>Эта команда скопирует оба файла <code>file1</code> и <code>file2</code> в
директорию <code>somedir/</code>. Вы не сможете скопировать несколько файлов в
один. Если вам действительно нужно сделать это, то следует воспользоваться
командой <strong>cat</strong>:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ cat file1 file2 &gt; combined_file</li>
  </ul>
</div>
      
<p>Вы можете использовать <strong>cp</strong> и для копирования директорий,
указав параметр <var>-R</var>. При этом рекурсивно скопируются все директории и
поддиректории. Если принимающая директория существует, то директория-источник
будет помещена в неё. Если её не существует, то она будет создана в случае,
если осуществляется копирование только одной директории.</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ cp -r mytree tree_copy</li>
    <li>$ mkdir trees</li>
    <li>$ cp -r mytree trees</li>
  </ul>
</div>
      
<p>По выполнению этих команд появятся две копии директории <code>mytree</code>:
<code>tree_copy</code> и <code>trees/mytree</code>. Попытка скопировать две
директории в несуществующую директорию обернётся неудачей:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ cp -R mytree mytree2 newdir</li>
    <li>usage:</li>
    <li>cp [-R [-H | -L | -P]] [-f | -i] [-pv] src target</li>
    <li>cp [-R [-H | -L | -P]] [-f | -i] [-pv] src1 ... srcN directory</li>
  </ul>
</div>
      
<div class="bq-note">
    <h4 class="text-success">Примечание</h4>
    <p>Традиционно, на многих UNIX-системах рекурсивное копирование осуществлялось
    при помощи параметра <var>-r</var>. Однако поведение этого параметра может
    зависеть от конкретной реализации, и спецификация UNIX версии 3
    постановила, что этот параметр может быть удалён в следующих версиях стандарта.</p>
</div>

<p>Когда вы копируете файлы рекурсивно, хорошей идеей будет заранее определить
поведение <strong>cp</strong> по отношению к символическим ссылкам.
Спецификация UNIX 3 версии не определяет поведение по умолчанию в данной
ситуации. Если используется параметр <var>-P</var>, <strong>cp</strong> не
будет следовать по символическим ссылкам, а только скопирует сами ссылки. Если
же используется параметр <var>-H</var>, то <strong>cp</strong> будет следовать
по ссылкам в зависимости от типа и содержимого файлов. Если используется
параметр <var>-L</var>, то <strong>cp</strong> будет следовать по ссылкам в
зависимости от содержимого файлов.</p>

<p>Если вы хотите сохранить информацию о владельцах файлов, биты SGID/SUID и
время доступа/модификации, вы можете использовать флаг <var>-p</var>. Тогда
будет предпринята попытка сохранить данные значения при копировании. Хорошая
реализация <strong>cp</strong> предоставляет некоторые дополнительные проверки,
например, защиту от перезаписи файлов со схожими метаданными.</p>

<h5>8.4.2. Перемещение файлов и директорий</h5>

<p>Команда UNIX для перемещения файлов, <strong>mv</strong>, может перемещать
или переименовывать файлы или директории. Что именно произойдёт, зависит от их
расположения. Если источник и приёмник находятся на одной файловой системе,
<strong>mv</strong> обычно просто создаёт новую жёсткую ссылку, тем самым
переименовывая файлы или директории. Если же оба из них находятся на разных
файловых системах, файлы действительно копируются, после чего источники
удаляются.</p>

<p>Синтаксис <strong>mv</strong> сравним с синтаксисом <strong>cp</strong>.
Наиболее общая команда, переименовывающая файл <code>file1</code> в
<code>file2</code> выглядит так:</p>


<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ mv file1 file2</li>
  </ul>
</div>
      
<p>Точно такой же синтаксис используется для изменения имени директории.</p>

<p>Когда последним параметром является существующая директория, файл или
директория, указанные первым параметром, будет перемещён в эту директорию.
Также можно указать несколько файлов для перемещения. Например:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ mkdir targetdir</li>
    <li>$ mv file1 directory1 targetdir</li>
  </ul>
</div>
      
<p>Это создаст директорию <code>targetdir</code> и переместит файл
<code>file1</code> и директорию <code>directory1</code> в эту директорию.</p>

<h5>8.4.3. Удаление файлов и директорий</h5>

<p>Удалить файлы и директории можно при помощи команды <strong>rm</strong> (1).
Данная команда удаляет ссылку на файл или директорию. Если не существует прочих
ссылок на этот файл, занятые им inode и блоки жёсткого диска будут доступны
новым файлам. При запуске <strong>rm</strong> следует передать ей имя файла в
качестве параметра. Например, для удаления файлов <code>file1</code> и
<code>file2</code> вы можете выполнить:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ rm file1 file2</li>
  </ul>
</div>

<p>Если вам нужно удалить большое количество файлов, которые запрашивают
подтверждение удаления, или вы хотите использовать <strong>rm</strong> в
сценарии командной оболочки, добавьте параметр <var>-f</var>, чтобы отключить
все уведомления. Файлы, которые не доступны для записи, с использованием флага
<var>-f</var> также будут удалены, если позволят права доступа. Этот параметр
также подавляет печать ошибок в стандартный поток вывода, если файл, который
должен быть удален, не был найден.</p>

<p>Для рекурсивного удаления директорий используется параметр <var>-r</var>.
<strong>rm</strong> (1) пройдёт по структуре каталогов и удалит каждый
встреченный файл. При указании параметра <var>-f</var> используется такая же
стратегия. В качестве краткого примера дадим команду, которая удалит все
вложенные файлы и директории в директории <code>notes</code>:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ rm -r notes</li>
  </ul>
</div>
      
<p>Так как команда <strong>rm</strong> (1) использует функцию
<strong>unlink</strong> (2), блоки данных не перезаписываются. Информация,
содержащаяся в блоках данных перезаписывается только тогда, когда
освободившееся пространство будет использовано. Чтобы надёжно удалить файлы,
включая всю информацию, можно использовать команду <strong>shred</strong> (1),
предоставляемую некоторыми системами. Эта команда перезаписывает блоки данных
случайной информацией. Правда, на многих современных (журналируемых) файловых
системах это не эффективно, так как они не сразу записывают данные на жёсткий
диск.</p>

<p>Команда <strong>unlink</strong> (1) является реализацией функции
<strong>unlink</strong> (2). От неё относительно мало пользы, так как она не
может удалять директории.</p>

<h4 id="7">8.7. Архивы</h4>

<h5>8.7.1. Введение</h5>

<p>Рано или поздно пользователь GNU/Linux столкнётся с архивами tar &#8211;
стандартным форматом архивирования файлов в этих системах. <strong>Tar</strong>
обычно используется вместе с <strong>gzip</strong> или <strong>bzip2</strong>.
Обе команды могут сжимать файлы и архивы. В следующей таблице перечислены самые
распространённые расширения архивов и их значения.</p>

<p class="text-right"><strong>Таблица 8.6 Расширения архивов</strong></p>

    <table class="table table-striped">
      <thead>
        <tr>
          <th>Расширение</th>
          <th>Значение</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>.tar</th>
          <td>Несжатый архив tar</td>
        </tr>
        <tr>
          <th>.tar.gz</th>
          <td>Tar-архив, сжатый при помощи <strong>gzip</strong></td>
        </tr>
        <tr>
          <th>.tgz</th>
          <td>Tar-архив, сжатый при помощи <strong>gzip</strong></td>
        </tr>
        <tr>
          <th>.tar.bz2</th>
          <td>Tar-архив, сжатый при помощи <strong>bzip2</strong></td>
        </tr>
        <tr>
          <th>.tbz</th>
          <td>Tar-архив, сжатый при помощи <strong>bzip2</strong></td>
        </tr>
      </tbody>
    </table>

<p>Разница между <strong>bzip2</strong> и <strong>gzip</strong> в том, что <strong>bzip2</strong> обнаруживает повторение данных в б<em>о</em>льших блоках, что даёт лучшее сжатие. Но в связи с этим <strong>bzip2</strong> работает медленнее, чем <strong>gzip</strong>.</p>

<h5>8.7.2. Распаковка архивов</h5>

<p>Так как в системах GNU/Linux данные и программы часто упакованы в архивы с
помощью <strong>tar</strong>, важно уметь распаковывать такие файлы. Первое,
что вы обычно захотите выполнить, получив tar-архив, &#8211; это
посмотреть его содержимое. Это можно сделать с помощью параметра
<var>t</var>. Однако, если вы выполните команду <strong>tar</strong> с
указанным параметром и именем файла, то программа будет ожидать
ввода:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ tar t test.tar</li>
  </ul>
</div>

<p>Это происходит потому, что <strong>tar</strong> читает данные из
стандартного потока ввода. Если вы забыли, как работает перенаправление
потоков, то перечитайте раздел <a href="07. Оболочка командной
строки.html#7">«7.7. Перенаправление ввода/вывода и конвееры»</a>. Давайте
рассмотрим, что произойдёт, если мы направим содержимое архива программе
<strong>tar</strong>:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ tar t &lg; test.tar</li>
    <li>test/</li>
    <li>test/test2</li>
    <li>test/test1</li>
  </ul>
</div>

<p>Это больше похоже на то, что мы ожидаем. Этот архив содержит директорию
<code>test</code>, в которой находятся файлы <code>test2</code> и
<code>test1</code>. Это также можно увидеть, указав параметр <var>f</var> и
передав имя файла:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ tar tf test.tar</li>
    <li>test/</li>
    <li>test/test2</li>
    <li>test/test1</li>
  </ul>
</div>

<p>Это выглядит так, будто архив содержит полезные файлы ;). Теперь мы можем
извлечь содержимое архива с помощью параметра <var>x</var>:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ tar xf test.tar</li>
  </ul>
</div>

<p>Мы можем проверить, извлеклись ли файлы, посмотрев содержимое директории с
помощью <strong>ls</strong>:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ ls test/</li>
    <li>test1  test2</li>
  </ul>
</div>

<p>Распаковка или просмотр содержимого архивов, сжатых с помощью <strong>gzip</strong> или <strong>bzip2</strong>
не многим сложнее. Нужно лишь добавить параметры <var>z</var> или <var>j</var>
соответственно. Например, мы можем отобразить содержимое архива, сжатого при
помощи <strong>gzip</strong>:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ tar ztf archive2.tar.gz</li>
  </ul>
</div>

<p>И <strong>bzip2</strong>-архив:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ tar jxf archive3.tar.bz2</li>
  </ul>
</div>

<h5>8.7.3. Создание архивов</h5>

<p>Вы можете создать архив при помощи параметра <var>c</var>. Допустим, что у
нас есть директория <code>test</code> из предыдущего примера. Мы можем
упаковать её в архив так:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ tar cf important-files.tar test</li>
  </ul>
</div>

<p>Это создаст архив с именем <code>important-files.tar</code> (которое
передано параметру <var>f</var>). Мы можем проверить архив:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ tar tf important-files.tar</li>
    <li>test/</li>
    <li>test/test2</li>
    <li>test/test1</li>
  </ul>
</div>

<p>Создание сжатых архивов осуществляется обычной командой архивирования
файлов, но с добавлением ключей: <var>z</var> для использования алгоритма <strong>gzip</strong>
и <var>b</var> для <strong>bzip2</strong>. Допустим, мы хотим создать сжатый <strong>gzip</strong>-архив
директории из предыдущих примеров. Мы можем сделать это таким образом:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li>$ tar zcf important-files.tar.gz test</li>
  </ul>
</div>

<br />

<h4 id="8">8.8. Подключение файловых систем</h4>

<h5>8.8.1. Введение</h5>

<p>Для доступа к файловым системам большая часть *ΝΙΧ-систем использует технику
под названием «монтирование» (mounting).</p>

<p>Монтирование означает, что файловая система будет подключена к какой-либо
директории корневой ФС. Например, CD-ROM может быть подключен к директории
/mnt/cdrom. Linux поддерживает множество типов файловых систем, таких как Ext2,
Ext3, ReiserFS, JFS, XFS, ISO9660 (используется для CD-ROM), UDF (используется
в некоторых DVD) и ФС DOS/Windows, такие как FAT, FAT32 и NTFS. Эти файловые
системы могут находиться на различных видах устройств, например, жёстких
дисках, оптических приводах и flash-накопителях.</p>

<p>Этот раздел описывает, как подключаются и отключаются файловые системы.</p>

<h5>8.8.2. mount</h5>

<p>Mount используется для подключения файловых систем. Простейший синтаксис
следующий: <strong>mount</strong> <var>/dev/&lt;устройство&gt; /&lt;точка
подключения&gt;</var>. Устройство может быть любым блочным устройством, таким
как жёсткий диск или привод CD-ROM. Точка подключения может быть произвольной
директорией в корневой файловой системе. Давайте рассмотрим пример:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li># mount /dev/cdrom /mnt/cdrom</li>
  </ul>
</div>

<p>Эта команда подключит устройство <code>/dev/cdrom</code> к директории
<code>/mnt/cdrom.</code> Обычно <code>/dev/cdrom</code> ссылкается на имя
реального устройства CD-ROM (например, <code>/dev/hdc</code>). Как вы можете
видеть, концепция действительно очень проста, нужно лишь немного
времени, чтобы заучить имена устройств ;). Иногда необходимо указать, какой
именно тип файловой системы вы пытаетесь подключить. Тип ФС указывается при
помощи параметра <var>-t</var>:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li># mount -t vfat /dev/sda1 /mnt/flash</li>
  </ul>
</div>

<p>Это примонтирует устройство <code>/dev/sda1</code> с файловой системой vfat
к точке <code>/mnt/flash</code>.</p>

<h5>8.8.3. umount</h5>

<p>Команда <strong>umount</strong> используется для отключения (отмонтирования)
файловых систем. <strong>Umount</strong> принимает два типа параметров, точки
подключения или имена устройств. Например:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
    <li># umount /mnt/cdrom</li>
    <li># umount /dev/sda1</li>
  </ul>
</div>

<p>Первая команда отмонтирует все файловые системы, которые подключены в
директорию <code>/mnt/cdrom</code>, вторая команда отключит раздел на
<code>/dev/sda1</code>.</p>

<h5>8.8.4. Файл fstab</h5>

<p>В GNU/Linux есть специальный файл, <code>/etc/fstab</code>, который
определяет файловые системы, которые будут подключены во время загрузки
системы. Давайте разберём пример:</p>

<pre class="brush: plain">
/dev/hda10  swap          swap     defaults         0   0
/dev/hda5   /             xfs      defaults         1   1
/dev/hda6   /var          xfs      defaults         1   2
/dev/hda7   /tmp          xfs      defaults         1   2
/dev/hda8   /home         xfs      defaults         1   2
/dev/hda9   /usr          xfs      defaults         1   2
/dev/cdrom  /mnt/cdrom    iso9660  noauto,owner,ro  0   0
/dev/fd0    /mnt/floppy   auto     noauto,owner     0   0
devpts      /dev/pts      devpts   gid=5,mode=620   0   0
proc        /proc         proc     defaults         0   0
</pre>

<p>Как вы можете видеть, каждая запись в файле fstab состоит из пяти полей:
<var>fs_spec</var>, <var>fs_file</var>, <var>fs_vfstype</var>,
<var>fs_mntops</var>, <var>fs_freg</var> и <var>fs_passno</var>. Далее мы
рассмотрим каждую из этих опций.</p>

<h6>8.8.4.1. fs_spec</h6>

<p>Опция <var>fs_spec</var> указывает для монтирования блочное устройство или удалённую
файловую систему. Как вы можете видеть в примере, существует несколько разделов
<code>/dev/hda</code>, а также CD-ROM и дисковод. Когда NFS-тома подключены,
можно указать IP-адрес и директорию для монтирования, например:
<code>192.168.1.10:/exports/data</code>.</p>

<h6>8.8.4.2. fs_file</h6>

<p><var>fs_file</var> определяет точку монтирования. Ею может быть произвольная
директория в файловой системе.</p>

<h6>8.8.4.3. fs_vfstype</h6>

<p>Эта опция указывает тип файловой системы. Например, она может принимать
значения <var>ext2</var>, <var>ext3</var>, <var>reiserfs</var>, <var>xfs</var>,
<var>nfs</var>, <var>vfat</var> или <var>ntfs</var>.</p>

<h6>8.8.4.4. fs_mntops</h6>

<p>Опция <var>fs_mntops</var> определяет параметры, которые должны быть
использованы при подключении файловых систем. Страница руководства команды
mount содержит подробное описание доступных параметров. Вот наиболее интересные
из них:</p>

<p><var>noauto</var>: файловые системы, перечисленные в
<code>/etc/fstab</code>, обычно подключаются автоматически. Однако если указана
эта опция, файловая система не будет примонтирована во время загрузки ОС, это
можно будет сделать только командой mount. Причём для этого следует указать
только точку монтирования или же имя устройства. Например: <strong>mount
/mnt/cdrom</strong>.</p>

<p><var>user</var>: добавление этой опции позволит обычным пользователям
подключать данную файловую систему (по умолчанию только суперпользователь может
монтировать ФС).</p>

<p><var>owner</var>: данная опция определяет владельца устройства, который
сможет его подключать. Вы можете определить владельца файла устройства при
помощи команды <strong>ls</strong>, например, так: <strong>ls -l
/dev/cdrom</strong>.</p>

<p><var>noexec</var>: после включения данной опции пользователи не смогут
запускать исполнимые файлы. Это может быть запрещено в целях безопасности.</p>

<p><var>nosuid</var>: эта опция сравнима с приведённой выше
(<var>noexec</var>), но она отключает все SUID-флаги на файлах. SUID-флаги
используются для того, чтобы обычные пользователи могли запустить файл с
привелегиями его владельца. Это может быть небезопасно, поэтому данная опция
используется главным образом для портативных накопителей. В том случае, если ФС
подключается обычным пользователем, SUID-флаги не учитываются, но
суперпользователь может подключить файловую систему в стандартном режиме.</p>

<p><var>unhide</var>: данная опция относится только к CD-дискам с файловой
системой ISO9660, она включает отображение скрытых файлов.</p>

<h6>8.8.4.5. fs_freq</h6>

<p>Если значение этой опции равно 1 или выше, то это число будет означать
количество дней, по истечении которого будет делаться дамп ФС (резервная
копия). Этот параметр используется только в случае корректной
установки и настройки программы <strong>dump</strong>.</p>

<h6>8.8.4.6. fs_passno</h6>

<p>Это поле используется программой fsck для определения порядка проверки
файловых систем во время загрузки ОС.</p>

<br />
<ul class="pager">
  <li class="previous"><a href="07. Оболочка командной строки.html">&larr; 7. Оболочка командной строки</a></li>
  <li class="next"><a href="09. Работа с текстом.html">9. Работа с текстом &rarr;</a></li>
</ul>

        </div>

        <div class="col-lg-1">
        </div>

      </div>

      <div class="footer">
        <p align="center"></p>
      </div>

    </div>

    <script src="../../../../../../js/jquery-2.1.0.min.js"></script>
    <script src="../../../../../../js/bootstrap.min.js"></script>

  </body>
</html>

