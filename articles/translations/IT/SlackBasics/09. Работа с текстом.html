<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="ru-RU">
  <head>
    <meta charset="utf-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Personal page">
    <meta name="author" content="Likhachev Maxim">

    <link rel="shortcut icon" href="../../../../ico/favicon.ico">

    <title>#!/usr/bin/env rm -- Заметки и переводы :: Основы Slackware Linux -- 9. Работа с текстом</title>

    <link rel="stylesheet" href="../../../../css/bootstrap.min.css">
    <link rel="stylesheet" href="../../../../css/custom.css">
    <link rel="stylesheet" href="../../../../css/fontello.css">
    <link rel="stylesheet" href="../../../../css/animation.css">

    <link rel="stylesheet" href="../../../../css/shell-wrap.css">

    <script type="text/javascript" src="../../../../js/SyntaxHighlighter/shCore.js"></script>

		<link href="../../../../css/SyntaxHighlighter/shCore.css" rel="stylesheet" type="text/css" />

		<link href="../../../../css/SyntaxHighlighter/shThemeEclipse.css" rel="stylesheet" type="text/css" />
		<!-- <link href="../../../../css/SyntaxHighlighter/shThemeDjango.css" rel="stylesheet" type="text/css" /> -->
		<!-- <link href="../../../../css/SyntaxHighlighter/shThemeEmacs.css" rel="stylesheet" type="text/css" /> -->
		<!-- <link href="../../../../css/SyntaxHighlighter/shThemeFadeToGrey.css" rel="stylesheet" type="text/css" /> -->
		<!-- <link href="../../../../css/SyntaxHighlighter/shThemeMDUltra.css" rel="stylesheet" type="text/css" /> -->
		<!-- <link href="../../../../css/SyntaxHighlighter/shThemeMidnight.css" rel="stylesheet" type="text/css" /> -->
		<!-- <link href="../../../../css/SyntaxHighlighter/shThemeRDark.css" rel="stylesheet" type="text/css" /> -->

		<script type="text/javascript" src="../../../../js/SyntaxHighlighter/shBrushScheme.js"></script>
		<script type="text/javascript" src="../../../../js/SyntaxHighlighter/shBrushCpp.js"></script>
		<script type="text/javascript" src="../../../../js/SyntaxHighlighter/shBrushTcl_simple.js"></script>
		<script type="text/javascript" src="../../../../js/SyntaxHighlighter/shBrushBash.js"></script>
		<script type="text/javascript" src="../../../../js/SyntaxHighlighter/shBrushErlang.js"></script>
		<script type="text/javascript" src="../../../../js/SyntaxHighlighter/shBrushPlain.js"></script>
		<script type="text/javascript" src="../../../../js/SyntaxHighlighter/shBrushBash.js"></script>
		<script type="text/javascript" src="../../../../js/SyntaxHighlighter/shBrushLatex.js"></script>
		<script type="text/javascript" src="../../../../js/SyntaxHighlighter/shBrushHaskell.js"></script>
		<script type="text/javascript" src="../../../../js/SyntaxHighlighter/shBrushProlog.js"></script>
		<script type="text/javascript" src="../../../../js/SyntaxHighlighter/shBrushDiff.js"></script>
		<script type="text/javascript" src="../../../../js/SyntaxHighlighter/shBrushVim.js"></script>
		<script type="text/javascript" src="../../../../js/SyntaxHighlighter/shBrushJScript.js"></script>
		<script type="text/javascript" src="../../../../js/SyntaxHighlighter/shBrushBat.js"></script>
		<script type="text/javascript" src="../../../../js/SyntaxHighlighter/shBrushXml.js"></script>
		<script type="text/javascript" src="../../../../js/SyntaxHighlighter/shBrushCss.js"></script>

<script type="text/javascript">
			SyntaxHighlighter.defaults['toolbar'] = false;
			SyntaxHighlighter.all()
		</script>

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="container">
      <div class="header">
        <ul class="nav navbar-nav pull-right">
          <li class="menu-icon"><a href="../../../../index.html"><span class="icon-home"></span></a></li>
          <li class="menu-icon"><a href="../../../../programming.html"><span class="icon-tools"></span></a></li>
          <li class="menu-icon"><a href="../../../../poetry.html"><span class="icon-feather"></span></a></li>
          <li class="menu-icon"><a href="../../../../music.html"><span class="icon-note-beamed"></span></a></li>
          <li class="menu-icon active"><a href="../../../../articles.html"><span class="icon-book"></span></a></li>
          <li class="menu-icon"><a href="../../../../about.html"><span class="icon-user"></span></a></li>
        </ul>
        <h3 class="text-muted">#!/usr/bin/env rm</h3>
      </div>

      <ol class="plain breadcrumb">
        <li><a href="../../../../articles.html"><span class="icon-book"></span></a></li>
        <li><a href="index.html">Основы Slackware Linux</a></li>
        <li><a href="index.html#IX">II. Основы Slackware Linux</a></li>
        <li class="active">9. Работа с текстом</li>
      </ol>

      <div class="row columns">

        <h3 class="text-center">9. Работа с текстом</h3>

</br>

        <div class="col-lg-1">
        </div>

<div class="article col-lg-10 text-justify">

<p>Обработка текста &#8211; одна из тех вещей, что UNIX делает превосходно; работа с
текстом соответствует сущности UNIX-философии, как было описано в
<a href="02. Введение в Slackware Linux.html#4">разделе 2.4.</a>
Большая часть команд UNIX &#8211; это простые программы, которые читают данные из
стандартного потока ввода, производят над ними некоторые операции и направляют
результат в стандартный поток вывода. Эти программы действуют как фильтры, и их
можно соединять друг с другом. Это позволяет ползователю соединять программы
таким образом, каким сложно вообразить. В следующих частях мы увидим, как можно
создавать собственные фильтры.</p>

<p>Эта глава описывает несколько простых, но важных команд UNIX, которые
используются для работы с текстом. После этого мы погрузимся в регулярные
выражения &#8211; специальный язык для описания текстовых шаблонов.</p>





<h4 id="2">9.2. Регулярные выражения</h4>

<h5>9.2.1. Введение</h5>

<p>Во время ежедневного использования компьютера, у вас частно будет возникать
необходимость сопоставить некоторый текст с шаблоном, а не с конкретной
строкой. Множество утилит UNIX реализуют поддержку языка для записи таких
шаблонов &#8211; регулярными выражениями (regular expressions, regexps). Во время
развития регулярных выражений, они разделились на три большие группы:</p>

<ul>
  <li>Традиционные регулярные выражения.</li>
  <li>Расширенные регулярные выражения POSIX.</li>
  <li>Регулярные выражения, совместимые с Perl (Perl-compatible regular expressions, PCRE).</li>
</ul>

<p>Регулярные выражения POSIX являются расширенной версией регулярных выражений
UNIX, а PCRE &#8211; расширенным вариантом POSIX-версии. Синтаксис регулярных
выражений зависит от конкретного приложения, но большая часть программ
поддерживает как минимум вариант POSIX.</p>

<p>Каждый синтаксический элемент регулярного выражения представляет одну из
следующих сущностей:</p>

<ul>
  <li><strong>Символ:</strong> основа любого регулярного выражения; символы
  или их наборы сопоставляются с соответствующими символами во входном потоке
  текста. Например, буква <var>&laquo;p&raquo;</var> или знак
  <var>&laquo;,&raquo;</var></li>
  <li><strong>Квантификатор:</strong> определяет, сколько раз предыдущий символ
  или набор символов встречаются в тексте.</li>
  <li><strong>Альтернативы:</strong> используются для поиска подстроки вида
  <var>&laquo;a или b&raquo;</var>, где <var>a</var> и <var>b</var> могут быть
  символами или регулярными выражениями.</li>
  <li><strong>Группировка:</strong> используется для объединения частей
  выражения для квантификации или создания альтернатив.</li> </ul>
<p></p>

<h5>9.2.2. Традиционные регулярные выражения UNIX</h5>

<p>Эта часть описывает традиционные регулярные выражения UNIX. По причине
недостаточности стандартизации, конкретный синтаксис регулярных выражений,
поддерживаемый программами, может немного отличаться от описываемого. Обычно,
страница руководства команды предоставляет детальную информацию о
поддерживаемом формате традиционных регулярных выражений. Разумно выучить
традиционный синтаксис, но в собственных сценариях использовать
POSIX-расширение.</p>

<h6 id="chars">9.2.2.1. Сопоставление с символами</h6>

<p>Символы обозначают сами себя. Если символ является синтаксической
конструкцией регулярных выражений, вы можете экранировать его, добавив обратную
косую черту. Например, <var>\+</var> будет совпадать со знаком плюса.</p>

<p>Точка (<var>.</var>) совпадает с любым символом. Так, регулярное выражение
<var>b.g</var> совпадает со строками <var>bag</var>, <var>big</var> и
<var>blg</var>, но не с <var>bit</var>.</p>

<p>Символ точки даёт слишком много свободы. Вы можете использовать квадратные
скобки (<var>[]</var>) для более точного указания символов, с которыми нужно
сопоставить текст. Например, регулярное выражение <var>b[aei]g</var> совпадёт
только со строками <var>bag</var>, <var>beg</var> и <var>big</var> и больше ни
с какими. Также вы можете указать те символы, которые не должны встречаться в
строке, используя квадратные скобки и знак циркумфлекса (<var>^</var>), стоящий
первым символом в наборе. Например, с регулярным выражением <var>b[^aei]g</var>
совпадут любые строки, состоящие из трёх символов, начинающиеся на <var>b</var>
и оканчивающиеся на <var>g</var>, кроме строк <var>bag</var>, <var>beg</var> и
<var>big</var>. Также возможно указывать диапазон символов с помощью дефиса
(<var>-</var>). Например, <var>a[0-9]</var> обозначает символ <var>a</var>, за
которым следует любая цифра от <var>0</var> до <var>9</var>.</p>

<p>Два специальных символа &#8211; циркумфлекс (<var>^</var>) и знак доллара
(<var>$</var>), &#8211; обозначают начало и конец строки. Это очень очень удобно при
разборе файлов. К примеру, вы можете найти все строки, начинающиеся со знака
решётки (<var>#</var>), регулярным выражением <var>^#</var>.</p>

<h6>9.2.2.2. Квантификаторы</h6>

<p>Простейший квантификатор, используемый для записи регулярных выражений, &#8211;
звезда Клини (<var>*</var>). Этот символ обозначает ноль или большее количество
совпадений. Например, регулярное выражение <var>ba*</var> совпадает со строками
<var>b</var>, <var>babaa</var> и т.д. Но вы должны знать, что одиночный символ
со следующей за ним звёздочкой будут совпадать с любой строкой, потому что
регулярному выражению <var>c*</var> соответствует строка, содержащая несколько
или <u>нисколько</u> символов <var>c</var>.</p>

<p>Более тонкая настройка повторяемости осуществляется с помощью экранированных
фигурных скобок; <var>\{x,y\}</var> обозначает повтор указанного символа как
минимум <var>x</var> раз, но не более <var>y</var> раз. Так, регулярному
выражению <var>ba\{1,3\} будут соответствовать строки <var>ba</var>,
<var>baa</var> и <var>baaa</var>.</p>

<h6>9.2.2.3. Группировка</h6>

<p>Экранированные обратной косой чертой скобки группируют разные символы таким
образом, что вы можете применить к ним всем квантификатор или указать группу
альтернативой. Например, регулярному выражению <var>\(ab\)\{1,3\} соответствуют
строки <var>ab</var>, <var>abab</var> и <var>ababab</var>.</p>

<h6>9.2.2.4. Альтернативы</h6>

<p>Экранированная вертикальная черта (<var>\|</var>) позволяет вам установить
альтернативные шаблоны. Это не несёт много смысла для одиночных символов,
потому как запись <var>a\|b</var> эквивалентна <var>[ab]</var>, но это удобно в
использовании с группами. Допустим, вам нужно составить выражение для поиска
строк <var>apple</var> и <var>pear</var> и никаких больше. Это можно легко
сделать с помощью альтернативы: <var>(apple)\|(pear)</var>.</p>

<h5>9.2.3. POSIX-расширение регулярных выражений</h5>

<p>Регулярные выражения POSIX являются надстройкой над традиционным синтаксисом
регулярных выражений и добавляют некоторое количество удобных в использовании
примитивов. Другое полезное отличие заключается в том, что не нужно
экранировать специальные знаки, обозначающие группировку, альтернативные
шаблоны или квантификаторы. Наоборот, их нужно экранировать для того, чтобы
сопоставлять эти конкретные символы. Большинство людей находит POSIX-синтаксис
более удобным, что делает его широко используемым.</p>

<h6>9.2.3.1. Сопоставление с символами</h6>

<p>Смысл обычных символов ничем не отличается от их значения в традиционных
регулярных выражениях, описанных в
<a href="#chars">разделе 9.2.2.1, &laquo;Сопоставление с символами&raquo;</a>.</p>

<h6>9.2.3.2. Квантификаторы</h6>

<p>В дополнение к звезде Клини (<var>*</var>), которая обозначает ноль или
более вхождений предыдущего символа, POSIX-расширение регулярных выражений
добавляет два новых примитива: знак плюса (<var>+</var>), соответствующий
одному или более вхождениям предыдущего символа или группы символов, и
вопросительный знак (<var>?</var>), который обозначает ноль или одно вхождение.
Например, выражению <var>a+</var> соответствует строка <var>a</var> (и все
строки, содержащие несколько символов <var>a</var>), но не соответствует
строка, не содержащая символа <var>a</var>. Регулярному же выражению
<var>ba?d</var> соответствуют строки <var>bd</var> и <var>bad</var>, но не
<var>baad</var> или <var>bed</var>.</p>

<p>Фигурные скобки используются для обозначения повторения, точно так же, как и
в традиционном синтаксисе. но косая черта должна быть упущена. Для поиска строк
<var>ba</var> и <var>baa</var> вместо выражения <var>ba\{1,2\}</var> нужно
использовать <var>ba{1,2}</var>.</p>

<h6>9.2.3.3. Группировка</h6>

<p>Группировка символов выполняется тем же образом, что и в традиционных
регулярных выражениях, только, соответственно, без экранирования скобок.
Например, регулярному выражению <var>(ab){1,3}</var> соответствуют строки
<var>ab</var>, <var>abab</var> и <var>ababab</var>.</p>

<h6>9.2.3.4. Альтернативы</h6>

<p>То же самое можно сказать и о записи альтернативных шаблонов. Так, для
поиска слов <var>apple</var> и <var>pear</var> подойдёт выражение
<var>(apple)|(pear)</var>.</p>





<h4 id="3">9.3. grep</h4>

<h5>9.3.1. Простое использование grep</h5>

<p>Сейчас мы обратимся к одной из самых важных утилит в UNIX-подобных системах
и впервые используем регулярные выражения. Команда <strong>grep</strong>
используется для поиска шаблона в потоке текста или файле. Шаблон представляет
собой регулярное выражение и может быть записан в простом формате или с
использованием расширений POSIX (при этом нужно указать параметр <var>-E</var>).
По умолчанию <strong>grep</strong> выводит строки, совпавшие с шаблоном, в
стандартный поток вывода. В простейшем случае вы можете указать шаблон поиска в
качестве аргумента, и <strong>grep</strong> произведёт поиск по этому шаблону в
стандартном потоке ввода. Это будет полезно для практики в составлении
регулярных выражений.</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
<li>$ grep '^\(ab\)\{2,3\}$'</li>
<li>ab</li>
<li>abab</li>
<li>abab</li>
<li>ababab</li>
<li>ababab</li>
<li>abababab</li>
</ul>
</div>
      
<p>Выше показан пример использования простого регулярного выражения,
совпадающего со строками, содержащими две или три подстроки
<var>&laquo;ab&raquo;</var>. Вы можете записать то же самое без экранирования
специальных символов, если укажете параметр <var>-E</var>:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
<li>$ grep -E '^(ab){2,3}$'</li>
<li>ab</li>
<li>abab</li>
<li>abab</li>
<li>ababab</li>
<li>ababab</li>
<li>abababab</li>
</ul>
</div>
      
<p>По умолчанию <strong>grep</strong> читает стандартный ввод, но вы можете
встроить его в конвеер, чтобы обработать вывод какой-либо программы. Например,
если вам нужно найти подстроку <var>&laquo;2006&raquo;</var> в третьей колонке
файла, вы можете объединить в одном конвеере программы <strong>cut</strong> и
<strong>grep</strong>:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
<li>$ cut -f 3 | grep '2006'</li>
</ul>
</div>
      
<h5>9.3.2. Поиск по файлам</h5>

<p><strong>Grep</strong> умеет производить поиск не только в стандартном потоке
ввода, но и по файлам. Как обычно в UNIX, для этого нужно указать файл
последним аргументом. Следующий пример выведет все строки из файла
<code>/etc/passwd</code>, начинающиеся с подстроки <var>daniel</var>:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
<li>$ grep "^daniel" /etc/passwd</li>
<li>daniel:*:1001:1001:Daniel de Kok:/home/daniel:/bin/sh</li>
</ul>
</div>
      
<p>С указанной опцией <var>-r</var> <strong>grep</strong> будет искать
вхождение подстроки рекурсивно по всей структуре директорий. Но для лучшей
переносимости можно комбинировать <strong>grep</strong> и <strong>find</strong>
с параметром <var>-exec</var>.</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
<li>$ grep -r 'somepattern' somedir</li>
</ul>
</div>
      
<p>Этой непереносимой функции соответствует следующая переносимая:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
<li>$ find /somedir -type f -exec grep 'somepattern' {} \; -print</li>
</ul>
</div>
      
<h5>9.3.3. Управление поиском</h5>

<p>Также <strong>grep</strong> может вывести строки, которые <u>не содержат</u>
шаблон поиска, если указать параметр <var>-v</var>:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
<li>$ grep -Ev '^(ab){2,3}$'</li>
<li>ab</li>
<li>ab</li>
<li>abab</li>
<li>ababab</li>
<li>abababab</li>
<li>abababab</li>
</ul>
</div>
      
<p>Если вы желаете включить регистронезависимый поиск, то вам нужно указать
параметр <var>-i</var>. Например:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
<li>$ grep -i "a"</li>
<li>a</li>
<li>a</li>
<li>A</li>
<li>A</li>
</ul>
</div>
      
<p>Также вы можете осуществить буквальный поиск подстроки с параметром
<var>-F</var>:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
<li>$ grep -F 'aa*'</li>
<li>a</li>
<li>aa*</li>
<li>aa*</li>
</ul>
</div>
      
<h5>9.3.4. Использование множественных шаблонов</h5>

<p>Как мы видели, вы можете использовать указывать альтернативы поиска с
помощью знака &laquo;|&raquo;. Но если шаблоны, которые требуется найти, сильно
различаются, удобнее будет указать два разных шаблона. <strong>Grep</strong>
позволяет вам использовать более одного шаблона, разделяя их символом новой
строки. Так, к примеру, если вы желаете вывести все строки, совпадающие с
шаблонами <var>&laquo;a&raquo;</var> и <var>&laquo;b&raquo;</var>, то это можно
сделать, введя их на разных строках:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
<li>$ grep 'a</li>
<li>b'</li>
<li>a</li>
<li>a</li>
<li>b</li>
<li>b</li>
<li>c</li>
</ul>
</div>
      
<p>Это работает потому, что используются кавычки. Но такое указание шаблонов
неудобно. <strong>Grep</strong> предоставляет параметр <var>-e</var>, с помощью
которого можно указать несколько поисковых запросов на одной строке. Вызвать
<strong>grep</strong> с параметрами как в предыдущем примере можно следующим
образом:</p>

<div class="shell-wrap">
  <p class="shell-top-bar">user@darkstar:~</p>
  <ul class="shell-body">
<li>$ grep -e 'a' -e 'b'</li>
</ul>
</div>
      

</br>
<ul class="pager">
  <li class="previous"><a href="08. Файлы и директории.html">&larr; 8. Файлы и директории</a></li>
  <li class="next"><a href="10. Управление процессами.html">10. Управление процессами &rarr;</a></li>
</ul>

        </div>

        <div class="col-lg-1">
        </div>

      </div>

      <div class="footer">
        <p align="center"></p>
      </div>

    </div>

    <script src="../../../../js/jquery-2.1.0.min.js"></script>
    <script src="../../../../js/bootstrap.min.js"></script>

  </body>
</html>

